#ifndef SMART_DATA_TYPES_H
#define SMART_DATA_TYPES_H

#include "smart_config.h"
#include "smart_message_constants.h"

//Keep this File C Compatible
#ifdef __cplusplus
	extern "C" {
#endif

#define MAX_RANGE_TO_OBJECT 6 //Meters
#define MAX_EEG_ELECTRODES  32

//##############SMART Data Types##############

//====================EEG Types====================
typedef enum Emotiv_Electrodes
{
    F3=0, FC6, P7, T8 , F7,
    F8  , T7 , P8, AF4, F4,
    AF3 , O2 , O1, FC5, NUM_EMOTIV_ELECTRODES
} Emotiv_Electrodes;

//This struct defines what a single frame of EEG Data looks like
typedef struct EEG_Frame_t
{
    //The type of EEG that the frame belongs to, appended by EEG IO class
    eegTypeEnum eegType;

    uint32_t counter; //Value counter

    //Data from Each electrode, defaults to 0
    uint32_t electrodeData[MAX_EEG_ELECTRODES];

    //Contact Quality from Each electrode, defaults to 0
    uint16_t contactQuality[MAX_EEG_ELECTRODES];

    //Gyro Values
    uint8_t gyroX;
    uint8_t gyroY;

    //Percentage of Full Battery Charge
    uint8_t batteryPercentage;
} EEG_Frame_t;
//===============================================

//====================BRS Types====================
typedef struct GPS_Data_t
{
    float latitude;
    float longitude;
    float altitude;
    float groundSpeed;
} GPS_Data_t;

typedef struct US_Data_t
{
    float rangeToObject;
} US_Data_t;

typedef struct SensorData_t
{
	GPS_Data_t gpsData;
	US_Data_t  rangeFinderData;
} SensorData_t;

// A Frame of BRS Data
typedef struct BRS_Frame_t
{
	MSG_ID_Type      MsgId; //Message Sent from BRS to BCI
	SensorData_t     sensorData
    PCC_Command_Type remoteCommand;
} BRS_Frame_t;
//===============================================


//==================Flasher Types==================
#define	LED_FORWARD_FREQ_DEFAULT  10
#define	LED_BACKWARD_FREQ_DEFAULT 20
#define	LED_RIGHT_FREQ_DEFAULT    30
#define	LED_LEFT_FREQ_DEFAULT     40
typedef enum
{
    LED_FORWARD=0,
    LED_BACKWARD,
    LED_RIGHT,
    LED_LEFT,
    NUM_LED_GROUPS
} LED_Group_ID;

typedef struct LED_Group_t
{
	LED_Group_ID id;
	uint16_t     frequency;
} LED_Group_t;
//=================================================


typedef struct TM_Frame_t
{
    MSG_ID_Type          MsgId; //Message Sent From BCI -> BRS -> MD
    int                  timeStamp;
    EEG_Frame_t          eegFrame; //Only the Latest Frame, EEG Telemetry is managed by the C_EEG_IO class
    BRS_Frame_t          brsFrame;
    LED_Group_t          ledForward;
    LED_Group_t          ledBackward;
    LED_Group_t          ledRight;
    LED_Group_t          ledLeft;
    ConnectionStatusType eegConnectionStatus;
    ConnectionStatusType pccConnectionStatus;
    ConnectionStatusType brsConnectionStatus;
    ConnectionStatusType flasherConnectionStatus;
} TM_Frame_t;

typedef struct BluetoothFrame_t
{
	MSG_ID_Type      MsgId;
	PCC_Command_Type remoteCommand;
} BluetoothFrame_t;

//############################################

//*****************************************************************************
//
// The item size for the messages
//
//*****************************************************************************
#define BRS2BCI_SIZE     sizeof(BRS_Frame_t)
#define BCI2BRS_SIZE     sizeof(TM_Frame_t)
#define MD2BRS_SIZE      sizeof(BluetoothFrame_t)
#define BRS2MD_SIZE      sizeof(TM_Frame_t)
#define SENSOR_DATA_SIZE sizeof(SensorData_t);

//*****************************************************************************
//
// Data Type Creation/Initialization
//
//*****************************************************************************
BRS_Frame_t* createBRSFrame()
{
	size_t dataSize = 0;
	BRS_Frame_t* ptr = NULL;

	//Create Frame
	dataSize = sizeof(BRS_Frame_t);
	ptr      = (BRS_Frame_t*) malloc(dataSize);
	memset(ptr, 0, dataSize);

	//Return new allocated frame
	return ptr;
}

LED_Group_t* createLEDGroup(LED_Group_ID id)
{
	size_t dataSize = 0;
	LED_Group_t* ptr = NULL;

	//Create LED Group
	dataSize = sizeof(LED_Group_t);
	ptr      = (LED_Group_t*) malloc(dataSize);
	memset(ptr, 0, dataSize);

	//Initialize Defaults
}

EEG_Frame_t* createEEGFrame()
{
	size_t dataSize = 0;
	EEG_Frame_t* ptr = NULL;

	//Create Frame
	dataSize = sizeof(EEG_Frame_t);
	ptr      = (EEG_Frame_t*) malloc(dataSize);
	memset(ptr, 0, dataSize);

	//Initialize Defaults
	ptr->eegType = DEFAULT_EEG_TYPE;

	//Return new allocated frame
	return ptr;
}

TM_Frame_t* createTMFrame()
{
	size_t dataSize = 0;
	TM_Frame_t* ptr = NULL;
	EEG_Frame_t* tmpEEGFrame = createEEGFrame();
	BRS_Frame_t* tmpBRSFrame = createBRSFrame();

	//Create Frame
	dataSize = sizeof(TM_Frame_t);
	ptr      = (TM_Frame_t*) malloc(dataSize);
	memset(ptr, 0, dataSize);

	//Initialize Defaults
	memcpy(&ptr->eegFrame,tmpEEGFrame, sizeof(EEG_Frame_t));
	memcpy(&ptr->brsFrame,tmpBRSFrame, sizeof(BRS_Frame_t));
	ptr->pccConnectionStatus     = NOT_CONNECTED;
	ptr->brsConnectionStatus     = NOT_CONNECTED;
	ptr->eegConnectionStatus     = NOT_CONNECTED;
	ptr->flasherConnectionStatus = NOT_CONNECTED;

	//Free Temp Memory Space
	free(tmpBRSFrame);
	free(tmpEEGFrame);

	//Return new allocated frame
	return ptr;
}

#ifdef _cplusplus
	} //extern "C"
#endif

#endif //SMART_DATA_TYPES_H
